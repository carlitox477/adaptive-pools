// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {BaseHook} from "@uniswap/v4-periphery/contracts/BaseHook.sol";

error UnsafeCasting();

contract SuperDynamicFeesHook is BaseHook {
    uint24 constant ONE_HUNDREAD_PERCENT = 100;
    uint24 immutable AVG_LIQUIDITY_VOLUME_THESHOLD_PERCENT;
    uint24 immutable EPOCHS_TO_TRACK;
    uint64 immutable EPOCH_DURATION;
    uint24 immutable MIN_FEE;
    uint24 immutable MAX_FEE;
    uint24 immutable EPOCH_DELTA_FEE;
    
    PoolId poolId;
    uint128 finalizedEpochs;
    uint256[] lastEpochsVolume;
    uint64 lastSwapTimestamp;
    uint64 lastEpochUpdate;
    uint256 finishedEpochs;
    uint256 currentEpochLiquidityVolume;
    uint256 sumLastEpochLiquidityVolume; // type justification: ease implementation

    uint256 _feeGrowthBeforeSwap0X128;
    uint256 _feeGrowthBeforeSwap1X128;

    constructor(
        IPoolManager _poolManager,
        uint24 epochsToTrack,
        uint64 epochDuration,
        uint24 minFee,
        uint24 maxFee,
        uint24 epochDeltaFee,
        uint24 avgLiquidityVolumeThreshold
    ) BaseHook(_poolManager){
        require(epochDuration != 0);
        require(minFee < maxFee);
        require(minFee % epochDeltaFee == 0);
        require(maxFee % epochDeltaFee == 0);
        require(avgLiquidityVolumeThreshold > 0);
        require(avgLiquidityVolumeThreshold < ONE_HUNDREAD_PERCENT);
        

        EPOCHS_TO_TRACK = epochsToTrack; 
        EPOCH_DURATION = epochDuration;
        MIN_FEE = minFee;
        MAX_FEE = maxFee;
        EPOCH_DELTA_FEE = epochDeltaFee;
        AVG_LIQUIDITY_VOLUME_THESHOLD_PERCENT = avgLiquidityVolumeThreshold;
        lastEpochsVolume = new uint256[](epochsToTrack);

    }

    function beforeSwap(
        address, 
        PoolKey calldata,
        IPoolManager.SwapParams calldata swapParams,
        bytes calldata
    )
        external
        override
        poolManagerOnly()
        returns (bytes4)
    {
        if(_isNewEpoch()){
            _recordEpochLiquidityVolume();
 

            // Calculate AVG volume in last
            // If finalizedEpochs < EPOCHS_TO_TRACK dynamics fees is disabled
            if(finalizedEpochs >= EPOCHS_TO_TRACK){
                uint256 avgLiquidityVolume = _calculateAvgLiquidityVolume();
                (uint256 minThreshold, uint256 maxThreshold) = _calculateAvgLiquidityVolumeThresholds(avgLiquidityVolume);
                _updateFees(avgLiquidityVolume,minThreshold,maxThreshold);
            }
            sumLastEpochLiquidityVolume = currentEpochLiquidityVolume;

            lastEpochUpdate = block.timestamp; //
            currentEpochLiquidityVolume = 0;
            
        }

        lastSwapTimestamp = block.timestamp;

        // Get fee growth to calculate used liquidity in after swap hook
        _recordFeesBeforeSwap();
    }

    function _isNewEpoch() internal view returns(bool){
        return lastEpochUpdate + EPOCH_DURATION < lastSwapTimestamp;
    }

    function _recordEpochLiquidityVolume() internal {
        uint256 epochIndex = finalizedEpochs % EPOCHS_TO_TRACK;
        int256 _lastEpochLiquidityVolume = int256(lastEpochsVolume[epochIndex]);
        int256 _currentEpochLiquidityVolume = int256(currentEpochLiquidityVolume);

        if(
            _lastEpochLiquidityVolume < 0 ||
            _currentEpochLiquidityVolume < 0 
        ){
            revert UnsafeCasting();
        }

        lastEpochsVolume[epochIndex] = currentEpochLiquidityVolume;
        unchecked{
            ++finalizedEpochs;
        }
    }

    function _calculateAvgLiquidityVolume() view returns (uint256){
        if(finalizedEpochs >= EPOCHS_TO_TRACK){
            return sumLastEpochLiquidityVolume / EPOCHS_TO_TRACK;
        }
    }

    function _calculateAvgLiquidityVolumeThresholds(
        uint256 avgLiquidityVolume
    ) view returns (uint256 minThreshold, uint256 maxThreshold){
        uint256 threshold = avgLiquidityVolume * AVG_LIQUIDITY_VOLUME_THESHOLD_PERCENT / ONE_HUNDREAD_PERCENT;
        minThreshold = avgLiquidityVolume - threshold;
        maxThreshold = avgLiquidityVolume + threshold;
    }

    function _getPoolCurrentFeePercentage() internal returns(uint256){
        (,,, uint24 swapFee) = poolManager.getSlot0(poolId);
        return swapFee;
    }

    function _getFeeGrowth() internal view returns(
        uint256 feeGrowthPerLiquityUnit0,
        uint256 feeGrowthPerLiquityUnit1
    ){
        Pool.State poolState = poolManager.pools(poolId);
        feeGrowthPerLiquityUnit0 = feeGrowthGlobal0X128;
        feeGrowthPerLiquityUnit1 = feeGrowthGlobal1X128;
    }

    function _recordFeesBeforeSwap(){
        (_feeGrowthBeforeSwap0X128,_feeGrowthBeforeSwap0X128) = _getFeeGrowth();
    }

    function _updateFees(
        uint256 avgLiquidityVolume,
        uint256 minThreshold,
        uint256 maxThreshold
    ){
        
        if(avgLiquidityVolume <= minThreshold){
            uint24 currentSwapFeePercentage = _getPoolCurrentFeePercentage();
            if(currentSwapFeePercentage != MIN_FEE){
                poolManager.updateDynamicSwapFee(poolId,currentSwapFeePercentage - EPOCH_DELTA_FEE);
            }
        }else if(avgLiquidityVolume >= maxThreshold){
            poolManager.updateDynamicSwapFee(poolKey);
            if(currentSwapFeePercentage != MAX_FEE){
                poolManager.updateDynamicSwapFee(poolId,currentSwapFeePercentage + EPOCH_DELTA_FEE);
            }
        }else{
            return;
        }
        // Do nothing if we are inside desired threshold
    }

    function _min(uint256 x, uint256 y) returns(uint256){
        return x < y ? x : y;
    }

    function _max(uint256 x, uint256 y) returns(uint256){
        return x > y ? x : y;
    }

    function _getPreviousEpochIndex()
        returns(uint256)
    {
        return (epochIndex + EPOCHS_TO_TRACK - 1) % EPOCHS_TO_TRACK;
    }


    function afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata swapParams, BalanceDelta, bytes calldata)
        external
        override
        poolManagerOnly()
        returns (bytes4)
    {
    
        // Update current liquidity volume
        (uint256 _feeGrowthAfterSwap0X128,uint256 _feeGrowthAfterSwap1X128) = _getFeeGrowth();
        uint256 feeGrowthInSwap0 = _feeGrowthAfterSwap0X128 - _feeGrowthBeforeSwap0X128;
        uint256 feeGrowthInSwap1 = _feeGrowthAfterSwap1X128 - _feeGrowthBeforeSwap1X128;

        if(swapParams.zeroForOne && swapParams.amountSpecified > 0){

        }else if(swapParams.zeroForOne && swapParams.amountSpecified < 0){

        }else if(!swapParams.zeroForOne && swapParams.amountSpecified < 0){

        }else if(!swapParams.zeroForOne && swapParams.amountSpecified > 0){

        }
    }

    function _calculateLiquidityUtilized(
        uint256 amountIn,
        uint256 decimals,
        uint256 feeGrowthInSwap
    ) internal returns(uint256){
        // Fee decimals
        return amountIn * decimals/ feeGrowthInSwap;
    }


    // fee amount gathered
    // fee perLiquidityAmountBeforeSwap
    //
}
